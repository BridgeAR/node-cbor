// Generated by CoffeeScript 1.6.3
(function() {
  var BREAK, BufferStream, EventedParser, MT, Simple, assert, async, constants, stream, utils,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  assert = require('assert');

  stream = require('stream');

  async = require('async');

  BufferStream = require('../lib/BufferStream');

  utils = require('../lib/utils');

  Simple = require('../lib/simple');

  constants = require('./constants');

  MT = constants.MT;

  BREAK = function() {
    return "BREAK";
  };

  EventedParser = (function(_super) {
    __extends(EventedParser, _super);

    function EventedParser(options) {
      this.options = utils.extend({
        max_depth: 512
      }, options);
    }

    EventedParser.prototype._drainState = function(state) {
      var kind, tags, _ref;
      tags = state.tags.slice();
      state.tags.length = 0;
      _ref = [null, state.kind], state.kind = _ref[0], kind = _ref[1];
      return [tags, kind];
    };

    EventedParser.prototype._val = function(state, val, cb) {
      var kind, tags, _ref;
      _ref = this._drainState(state), tags = _ref[0], kind = _ref[1];
      this.emit('value', val, tags, kind);
      return cb.call(this, null, val);
    };

    EventedParser.prototype._readBuf = function(state, len, cb) {
      var _this = this;
      return state.bs.wait(len, function(er, buf) {
        if (er) {
          return cb.call(_this, er);
        }
        return _this._val(state, buf, cb);
      });
    };

    EventedParser.prototype._readStr = function(state, len, cb) {
      var _this = this;
      return state.bs.wait(len, function(er, buf) {
        if (er) {
          return cb.call(_this, er);
        }
        return _this._val(state, buf.toString('utf8'), cb);
      });
    };

    EventedParser.prototype._readArray = function(state, count, cb) {
      var kind, tags, _ref,
        _this = this;
      _ref = this._drainState(state), tags = _ref[0], kind = _ref[1];
      this.emit('array start', count, tags, kind);
      return async.timesSeries(count, function(n, done) {
        state.kind = n ? 'array' : 'array first';
        return _this._unpack(state, done);
      }, function(er) {
        if (er) {
          return cb.call(_this, er);
        }
        _this.emit('array stop', count, tags, kind);
        state.mt = MT.ARRAY;
        return cb.call(_this);
      });
    };

    EventedParser.prototype._readMap = function(state, count, cb) {
      var kind, tags, up, _ref,
        _this = this;
      _ref = this._drainState(state), tags = _ref[0], kind = _ref[1];
      this.emit('map start', count, tags, kind);
      up = this._unpack.bind(this);
      return async.timesSeries(count, function(n, done) {
        return async.series([
          function(cb) {
            state.kind = n ? 'key' : 'key first';
            return up(state, cb);
          }, function(cb) {
            state.kind = 'value';
            return up(state, cb);
          }
        ], done);
      }, function(er) {
        if (er) {
          return cb.call(_this, er);
        }
        _this.emit('map stop', count, tags, kind);
        state.mt = MT.MAP;
        return cb.call(_this);
      });
    };

    EventedParser.prototype._readTag = function(state, val, cb) {
      state.tags.push(val);
      return this._unpack(state, cb);
    };

    EventedParser.prototype._readSimple = function(state, val, cb) {
      switch (val) {
        case 20:
          return this._val(state, false, cb);
        case 21:
          return this._val(state, true, cb);
        case 22:
          return this._val(state, null, cb);
        case 23:
          return this._val(state, void 0, cb);
        default:
          return this._val(state, new Simple(val), cb);
      }
    };

    EventedParser.prototype._getVal = function(state, val, cb) {
      switch (state.mt) {
        case MT.POS_INT:
          return this._val(state, val, cb);
        case MT.NEG_INT:
          return this._val(state, -1 - val, cb);
        case MT.BYTE_STRING:
          return this._readBuf(state, val, cb);
        case MT.UTF8_STRING:
          return this._readStr(state, val, cb);
        case MT.ARRAY:
          return this._readArray(state, val, cb);
        case MT.MAP:
          return this._readMap(state, val, cb);
        case MT.TAG:
          return this._readTag(state, val, cb);
        case MT.SIMPLE_FLOAT:
          return this._readSimple(state, val, cb);
        default:
          return cb.call(this, new Error("Unknown major type(" + state.mt + "): " + val));
      }
    };

    EventedParser.prototype._stream_stringy = function(state, cb) {
      var count, keep_going, kind, mt, tags, _ref,
        _this = this;
      mt = state.mt;
      _ref = this._drainState(state), tags = _ref[0], kind = _ref[1];
      count = 0;
      this.emit('stream start', mt, tags, kind);
      keep_going = true;
      return async.doWhilst(function(done) {
        state.kind = count ? 'stream' : 'stream first';
        return _this._unpack(state, function(er, val) {
          if (er) {
            return done(er);
          }
          if (val === BREAK) {
            keep_going = false;
          } else {
            if (state.mt !== mt) {
              return done(new Error("Invalid stream major type: " + state.mt + ", when anticipating only " + mt));
            }
            count++;
          }
          return done();
        });
      }, function() {
        return keep_going;
      }, function(er) {
        if (er) {
          return cb.call(that, er);
        }
        _this.emit('stream stop', count, mt, tags, kind);
        return cb.call(_this);
      });
    };

    EventedParser.prototype._stream_array = function(state, cb) {
      var count, keep_going, kind, mt, tags, _ref,
        _this = this;
      mt = state.mt;
      _ref = this._drainState(state), tags = _ref[0], kind = _ref[1];
      count = 0;
      this.emit('array start', -1, tags, kind);
      keep_going = true;
      return async.doWhilst(function(done) {
        state.kind = count ? 'array' : 'array first';
        return _this._unpack(state, function(er, val) {
          if (er) {
            return done(er);
          }
          if (val === BREAK) {
            keep_going = false;
          } else {
            count++;
          }
          return done();
        });
      }, function() {
        return keep_going;
      }, function(er) {
        if (er) {
          return cb.call(_this, er);
        }
        _this.emit('array stop', count, tags, kind);
        return cb.call(_this);
      });
    };

    EventedParser.prototype._stream_map = function(state, cb) {
      var count, keep_going, kind, mt, tags, _ref,
        _this = this;
      mt = state.mt;
      _ref = this._drainState(state), tags = _ref[0], kind = _ref[1];
      count = 0;
      this.emit('map start', -1, tags, kind);
      keep_going = true;
      return async.doWhilst(function(done) {
        state.kind = count ? 'key' : 'key first';
        return _this._unpack(state, function(er, val) {
          if (er) {
            return done(er);
          }
          if (val === BREAK) {
            keep_going = false;
            return done();
          } else {
            count++;
            state.kind = 'value';
            return this._unpack(state, done);
          }
        });
      }, function() {
        return keep_going;
      }, function(er) {
        if (er) {
          return cb.call(_this, er);
        }
        _this.emit('map stop', count, tags, kind);
        return cb.call(_this);
      });
    };

    EventedParser.prototype._stream = function(state, cb) {
      var kind, tags, _ref;
      switch (state.mt) {
        case MT.BYTE_STRING:
        case MT.UTF8_STRING:
          return this._stream_stringy(state, cb);
        case MT.ARRAY:
          return this._stream_array(state, cb);
        case MT.MAP:
          return this._stream_map(state, cb);
        case MT.SIMPLE_FLOAT:
          _ref = this._drainState(state), tags = _ref[0], kind = _ref[1];
          return cb.call(this, null, BREAK);
        default:
          return cb.call(this, new Error("Invalid stream major type: " + state.mt));
      }
    };

    EventedParser.prototype._unpack = function(state, cb) {
      var _this = this;
      return state.bs.wait(1, function(er, buf) {
        var decrement;
        if (er) {
          return cb(er);
        }
        state.depth++;
        if (state.depth > _this.options.max_depth) {
          return cb.call(_this, new Error("Maximum depth exceeded: " + state.depth));
        }
        state.octet = buf[0];
        state.mt = state.octet >> 5;
        state.ai = state.octet & 0x1f;
        decrement = function() {
          if (!(arguments[0] instanceof Error)) {
            state.depth--;
          }
          return cb.apply(this, arguments);
        };
        switch (state.ai) {
          case 24:
          case 25:
          case 26:
          case 27:
            return state.bs.wait(1 << (state.ai - 24), function(er, buf) {
              if (er) {
                return cb(er);
              }
              if (state.mt === MT.SIMPLE_FLOAT) {
                if (state.ai === 24) {
                  return _this._readSimple(state, utils.parseInt(state.ai, buf), decrement);
                } else {
                  return _this._val(state, utils.parseFloat(state.ai, buf), decrement);
                }
              } else {
                return _this._getVal(state, utils.parseInt(state.ai, buf), decrement);
              }
            });
          case 28:
          case 29:
          case 30:
            return cb(new Error("Additional info not implemented: " + ai));
          case 31:
            return _this._stream(state, decrement);
          default:
            return _this._getVal(state, state.ai, decrement);
        }
      });
    };

    EventedParser.prototype.unpack = function(buf, offset, encoding) {
      var bs, s, state, unpacked_one,
        _this = this;
      if (offset == null) {
        offset = 0;
      }
      if (encoding == null) {
        encoding = 'hex';
      }
      bs = buf;
      if (Buffer.isBuffer(bs)) {
        if (offset) {
          bs = bs.slice(offset);
        }
        bs = new BufferStream({
          bsInit: bs
        });
      } else if (bs instanceof stream.Readable) {
        bs = new BufferStream;
        buf.pipe(bs);
      } else if (typeof bs === 'string') {
        s = buf;
        if (encoding === 'hex') {
          s = s.replace(/^0x/, '');
        }
        if (offset) {
          s = s.slice(offset);
        }
        bs = new BufferStream();
        bs.end(s, encoding);
      } else if (!BufferStream.isBufferStream(bs)) {
        throw new Error("buf must be Buffer, string, or BufferStream");
      }
      state = {
        bs: bs,
        tags: [],
        kind: null,
        depth: 0
      };
      unpacked_one = function(er) {
        if (er) {
          if (BufferStream.isEOFError(er) && (state.depth === 0)) {
            return _this.emit('end');
          } else {
            return _this.emit('error', er);
          }
        }
        return async.nextTick(function() {
          if (state.bs.isEOF()) {
            return _this.emit('end');
          } else {
            return _this._unpack(state, unpacked_one);
          }
        });
      };
      return async.nextTick(function() {
        return _this._unpack(state, unpacked_one);
      });
    };

    return EventedParser;

  })(stream.Writable);

  module.exports = EventedParser;

}).call(this);
