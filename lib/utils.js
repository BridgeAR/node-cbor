/*jslint node: true */
"use strict";

var bignumber = require('bignumber.js');

var SHIFT32 = Math.pow(2,32);

exports.parseInt = function parseInt(ai, buf) {
  switch (ai) {
    case 24:
      return buf.readUInt8(0, true);
    case 25:
      return buf.readUInt16BE(0, true);
    case 26:
      return buf.readUInt32BE(0, true);
    case 27:
      var f = buf.readUInt32BE(0);
      var g = buf.readUInt32BE(4);
      return (f * SHIFT32) + g;
    default:
      throw new Error("Invalid additional info for int: " + ai);
  }
};

function parseHalf(buf) {
  var sign = (buf[0] & 0x80) ? -1 : 1;
  var exp = (buf[0] & 0x7C) >> 2;
  var mant = ((buf[0] & 0x03) << 8) | buf[1];
  if (!exp) {
    // subnormal
    // Math.pow(2, -24) = 5.9604644775390625e-8
    return sign * 5.9604644775390625e-8 * mant;
  }
  if (exp === 0x1f) {
    return sign * (mant ? NaN : Infinity);
  }
  return sign * Math.pow(2, exp-25) * (1024 + mant);
}
exports.parseHalf = parseHalf;

exports.parseFloat = function parseFloat(ai, buf) {
  switch (ai) {
    case 25:
      return parseHalf(buf);
    case 26:
      return buf.readFloatBE(0, true);
    case 27:
      return buf.readDoubleBE(0, true);
    default:
      throw new Error("Invalid additional info for float: " + ai);
  }
};

exports.hex = function hex(s) {
  return new Buffer(s.replace(/^0x/, ''), 'hex');
};

// Generated by CoffeeScript 1.6.3
exports.extend = function() {
  var a, adds, k, old, v, _i, _len;
  old = arguments[0], adds = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
  if (old == null) {
    old = {};
  }
  for (_i = 0, _len = adds.length; _i < _len; _i++) {
    a = adds[_i];
    for (k in a) {
      old[k] = a[k];
    }
  }
  return old;
};

exports.arrayEqual = function(a, b) {
  return (a.length === b.length) && a.every(function(elem, i) {
    return elem === b[i];
  });
};

exports.bufferToBignumber = function bufferToBignumber(buf) {
  // TODO: there's got to be a faster way to do this
  return new bignumber(buf.toString('hex'), 16);
};
